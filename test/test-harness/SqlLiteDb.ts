/**
 * SqlLiteDb.ts - Utility for querying SQLite database files used by the integration test harness.
 *
 * Usage:
 *   ts-node SqlLiteDb.ts <QUERY> [dbFile]
 *   npm run query-sqllite -- <QUERY> [dbFile]
 *
 * Supported QUERY values:
 *   - list_tables: List all tables in the database
 *   - print_tables: Print all rows from all tables
 *   - print_table:<tableName>: Print all rows from the specified table
 *   - custom_sql:<sqlStatement>: Run a custom SQL statement and print results
 *
 * If [dbFile] is omitted, the script will auto-detect a single .sqlite file in the storage directory.
 *
 * Example:
 *   ts-node SqlLiteDb.ts print_table:MyTable ./test/test-harness/storage/test-db.sqlite
 *   npm run query-sqllite -- custom_sql:SELECT COUNT(*) FROM MyTable
 *
 * This script is intended for inspecting and debugging the contents of SQLite databases generated by the test harness.
 */

import Database from 'better-sqlite3';
import fs from 'fs';
import path from 'path';

/**
 * Enum of supported "canned" queries
 */
export enum QUERY {
  LIST_TABLES = "list_tables",
  PRINT_TABLES = "print_tables",
  PRINT_TABLE = "print_table:",
  CUSTOM_SQL = "custom_sql:"
}

const sqlLiteDbDir: string = './storage';
const sqlLiteDbFile: string = `${sqlLiteDbDir}/test-db.sqlite`;
export const sqlLiteDbFileAbsolutePath: string = path.resolve(__dirname, sqlLiteDbFile);


export const run = () => {
  const queryArg = process.argv[2];

  // Validate queryArg: must match a QUERY value or start with PRINT_TABLE or CUSTOM_SQL
  const validQuery = Object.values(QUERY).includes(queryArg as QUERY)
    || queryArg.startsWith(QUERY.PRINT_TABLE)
    || queryArg.startsWith(QUERY.CUSTOM_SQL);
  if (!queryArg || !validQuery) {
    console.error(`Invalid or missing QUERY argument. Must be one of: ${Object.values(QUERY).join(', ')}\nOr start with '${QUERY.PRINT_TABLE}<tableName>' or '${QUERY.CUSTOM_SQL}<sqlStatement>'.\nUsage: ts-node SqlLiteDb.ts <QUERY> [dbFile]`);
    process.exit(1);
  }

  const dbFileArg = process.argv[3];
  let dbFile: string;

  // Determine the database file to use and validate its existence
  if (dbFileArg) {
    dbFile = dbFileArg;
  } else {
    // Try to find a single .sqlite file in sqlLiteDbDir
    const storageDir = path.resolve(__dirname, sqlLiteDbDir);
    const files = fs.readdirSync(storageDir).filter(f => f.endsWith('.sqlite') || f.endsWith('.sqllite'));
    if (files.length === 1) {
      dbFile = path.join(storageDir, files[0]);
    } else if (files.length === 0) {
      console.error(`No SQLite database file found in ${__dirname}/${sqlLiteDbDir}`);
      process.exit(1);
    } else {
      console.error(`Multiple SQLite database files found in ${__dirname}/${sqlLiteDbDir}. Please specify one as an argument.`);
      process.exit(1);
    }
  }

  console.log(`Using SQLite database file: ${dbFile}`);

  const db = new Database(dbFile);

  /**
   * List all tables in the database
   */
  const listAllTables = (log:boolean = true): { name: string }[] => {
    const tables = db.prepare("SELECT name FROM sqlite_master WHERE type='table';").all() as { name: string }[];
    if (log) {
      console.table(tables);
    }
    return tables;
  }

  /**
   * Print all content of all tables
   */
  const printAllTableContent = () => {
    const tables = listAllTables(false);
    for (const table of tables) {
      console.log(`\nContent of table '${table.name}':`);
      const rows = db.prepare(`SELECT * FROM ${table.name};`).all();
      console.table(rows);
    }
  }

  /**
   * Print all content of a single table
   */
  const listSingleTable = (tableName: string) => {
    /**
     * Run a custom SQL statement and print results
     */
    console.log(`\nContent of table '${tableName}':`);
    const rows = db.prepare(`SELECT * FROM ${tableName};`).all();
    console.table(rows);
  }

  /**
   * Print results of a custom SQL statement
   * @param sql 
   */
  const runCustomSql = (sql: string) => {
    if (!sql) {
      console.error(`CUSTOM_SQL query requires a SQL statement after the colon.`);
      process.exit(1);
    }
    try {
      const rows = db.prepare(sql).all();
      console.log(`\nResults for SQL: ${sql}`);
      console.table(rows);
    } catch (err) {
      console.error(`Error executing SQL: ${sql}`);
      process.exit(1);
    }
  }

  if (queryArg === QUERY.LIST_TABLES) {
    listAllTables();
  } 
  else if (queryArg.startsWith(QUERY.CUSTOM_SQL)) {
    const sql = queryArg.substring(QUERY.CUSTOM_SQL.length);
    runCustomSql(sql);
  } 
  else if (queryArg === QUERY.PRINT_TABLES) {
    printAllTableContent();
  } 
  else if (queryArg.startsWith(QUERY.PRINT_TABLE)) {
    const tableName = queryArg.substring(QUERY.PRINT_TABLE.length);
    if (!tableName) {
      console.error(`PRINT_TABLE query requires a table name after the colon.`);
      process.exit(1);
    }
    listSingleTable(tableName);
  } 
  else {
    console.error(`Unknown QUERY argument: ${queryArg}`);
    process.exit(1);
  }

  db.close();
}

if (require.main === module) {
  run();
}